@page "/History"
@inject IAccountService AccountService

<h3>Historik</h3>

<!-- Select account(s) -->
<div class="mb-3" style="max-width: 420px;">
    <label class="form-label">Välj konto..</label>
    <InputSelect @bind-Value="SelectedAccountId" class="form-select">
        <option value="">-- Alla konton --</option>
        @foreach (var account in _accounts)
        {
            <option value="@account.Id">@account.Name</option>
        }
    </InputSelect>
</div>
<!-- Date intervall -->
<div class="mb-3" style="max-width: 420px;">
    <label class="form-label">Datumintervall:</label>
    <div class="d-flex gap-2">
        <InputDate @bind-Value="StartDate" class="form-control" />
        <span>–</span>
        <InputDate @bind-Value="EndDate" class="form-control" />
    </div>
</div>


<!-- History -->
@if (_transactions is null)
{
    <div class="alert alert-light border" style="max-width: 720px;">
        Laddar transaktioner... 
    </div>
}
else if (!_transactions.Any())
{
    <div class="alert alert-light border" style="max-width: 720px;">
        Inga transaktioner hittades. 
    </div>
}
else
{
    <!-- List of selected account or all accounts -->
    <div class="table-responsive" style="width: 900px;">
        <table class="table table-striped align-middle">
            <thead class="table-light">
            <tr>
                <th style="cursor: pointer; user-select: none;" @onclick="ToggleDateSort">
                    Datum @(_sortDescending ? "▼" : "▲") 
                </th>
                <th>Typ</th> 
                <th style="cursor: pointer; user-select: none;" @onclick="ToggleAmountSort">
                    Belopp @(_sortByAmount ? (_sortAmountDescending ? "▼" : "▲") : "")
                </th>
                <th>Motpart</th>
                <th>Beskrivning</th> 
                <th></th>
            </tr>
            </thead>
            <tbody>
            @foreach (var tx in GetFilteredAndSortedTransactions(StartDate, EndDate)) 
            {
                <tr>
                    <td>@tx.LastUpdated.ToString("yyyy-MM-dd")</td> 
                    <td>@GetTransactionTypeForDisplay(tx)</td>
                    <td class="text-end @AmountTone(tx)">@FormatAmount(tx)</td> 
                    <td>@GetOtherPartyName(tx)</td> 
                    <td>@tx.Note</td>
                    <td>
                        <button class="btn btn-danger btn-sm" @onclick="() => DeleteTransaction(tx)">Ta bort</button> <!-- Delete button -->
                    </td>
                </tr>
            }
            </tbody>
        </table>
    </div>
}

@code {
    
    /// <summary>
    ///  List of bank accounts for the user
    /// </summary>
    private List<BankAccount> _accounts = new();
    private List<Transaction>? _transactions = null; // Null = laddar, tom lista = inga transaktioner
    private string? _errorMessage;
    private string _selectedAccountIdString = string.Empty;
    private bool _sortDescending = true; // Default: nyaste först - tillagd för sorteringsfunktionalitet
    
    private string SelectedAccountId
    {
        get => _selectedAccountIdString;
        set
        {
            if (_selectedAccountIdString != value)
            {
                _selectedAccountIdString = value;
                _ = LoadTransactionsAsync();
            }
        }
    }
    
    /// <summary>
    ///  Loads accounts and transactions on initialization
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        try
        {
            _accounts = (await AccountService.GetAccountsAsync()).ToList();
        }
        catch (Exception ex)
        {
            _errorMessage = $"FEL vid hämtning av konton: {ex.Message}";
        }
        _ = LoadTransactionsAsync();
    }
    
    /// <summary>
    ///  Loads transactions for the selected account or all accounts
    /// </summary>
    private async Task LoadTransactionsAsync()
    {    
        if (!Guid.TryParse(SelectedAccountId, out var accountId))
        {
            if (!_accounts.Any())
            {
                _transactions = new List<Transaction>();
                StateHasChanged();
                return;
            }

            _transactions = null;
            _errorMessage = null;
            StateHasChanged();

            try
            {
                var tasks = _accounts.Select(a => AccountService.GetTransactionsAsync(a.Id));
                var results = await Task.WhenAll(tasks);
                _transactions = results.SelectMany(r => r).ToList(); // Slå ihop alla transaktioner
            }
            catch (Exception ex)
            {
                _errorMessage = $"Ett fel inträffade vid hämtning av transaktioner: {ex.Message}";
                _transactions = new List<Transaction>();
            }
            finally
            {
                StateHasChanged();
            }

            return;
        }
        
        _transactions = null;
        _errorMessage = null;
        StateHasChanged();

        try
        {
            _transactions = (await AccountService.GetTransactionsAsync(accountId)).ToList();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Ett fel inträffade vid hämtning av transaktioner: {ex.Message}";
            _transactions = new List<Transaction>();
        }
        finally
        {
            StateHasChanged();
        }
    }

    /// <summary>
    ///  Gets the name of the other party in the transaction
    /// </summary>
    /// <param name="tx"></param>
    /// <returns></returns>
    private string GetOtherPartyName(Transaction tx)
    {
        var fromName = AccountName(tx.FromAccountId);
        var toName = AccountName(tx.ToAccountId);

        if (Guid.TryParse(SelectedAccountId, out var accountId))
        {
            if (tx.FromAccountId == accountId) return toName; 
            if (tx.ToAccountId == accountId) return fromName; 
        }
        return $"{fromName} → {toName}";
    }
    
    /// <summary>
    ///  Gets the transaction type for display purposes
    /// </summary>
    /// <param name="tx"></param>
    /// <returns></returns>
    private string GetTransactionTypeForDisplay(Transaction tx)
    {
        var isToInternal = tx.ToAccountId.HasValue && _accounts.Any(a => a.Id == tx.ToAccountId.Value);
        var isFromInternal = tx.FromAccountId.HasValue && _accounts.Any(a => a.Id == tx.FromAccountId.Value);

        if (Guid.TryParse(SelectedAccountId, out var accountId))
        {
            if (tx.FromAccountId == accountId)
            {
                return "Överföring";
            }
            if (tx.ToAccountId == accountId)
            {
                return "Insättning";
            }
        }
        if (isFromInternal && isToInternal)
        {
            return "Överföring"; 
        }
        if (isFromInternal)
        {
            return "Uttag"; 
        }
        if (isToInternal)
        {
            return "Insättning"; 
        }

        return tx.TransactionType.ToString();
    }
    
    // Gets the account name by its ID
    private string AccountName(Guid? accountId)
    {
        if (!accountId.HasValue || accountId.Value == Guid.Empty)
            return "Extern";

        var acc = _accounts.FirstOrDefault(a => a.Id == accountId.Value);
        if (acc != null)
            return acc.Name;

        return "Okänt konto";
    }
    
    // Formats the amount for display, considering the selected account
    private string FormatAmount(Transaction tx)
    {
        if (!Guid.TryParse(SelectedAccountId, out var parsedAccountId))
            return tx.Amount.ToString("C");

        return Math.Abs(tx.Amount).ToString("C");
    }
    
    // Determines the text color based on whether the transaction is an outgoing or incoming amount
    private string AmountTone(Transaction tx)
    {
        if (!Guid.TryParse(SelectedAccountId, out var parsedAccountId))
            return string.Empty;

        return tx.FromAccountId == parsedAccountId ? "text-danger" : "text-success";
    }
    private bool _sortAmountDescending = true;
    private bool _sortByAmount = false;
    
    // Toggles sorting by amount
    private void ToggleAmountSort()
    {
        _sortByAmount = true;
        _sortAmountDescending = !_sortAmountDescending;
        StateHasChanged();
    }
    
    // Toggles sorting by date
    private void ToggleDateSort()
    {
        _sortByAmount = false;
        _sortDescending = !_sortDescending;
        StateHasChanged();
    }
    
    /// <summary>
    ///  Gets transactions sorted by the selected criteria
    /// </summary>
    /// <returns></returns>
    private IEnumerable<Transaction> GetSortedTransactions()
    {
        if (_transactions == null) return Enumerable.Empty<Transaction>();
    
        if (_sortByAmount)
            return _sortAmountDescending
                ? _transactions.OrderByDescending(t => t.Amount)
                : _transactions.OrderBy(t => t.Amount);
    
        return _sortDescending
            ? _transactions.OrderByDescending(t => t.LastUpdated)
            : _transactions.OrderBy(t => t.LastUpdated);
    }
    
    /// <summary>
    ///  Deletes a transaction
    /// </summary>
    /// <param name="tx"></param>
    private async Task DeleteTransaction(Transaction tx)
    {
        await AccountService.DeleteTransactionAsync(tx.Id);
        
        _transactions?.Remove(tx);
        StateHasChanged();
    }

    /// <summary>
    /// Gets transactions filtered by date range and sorted
    /// </summary>
    /// <param name="startDate"></param>
    /// <param name="endDate"></param>
    /// <returns></returns>
    private IEnumerable<Transaction> GetFilteredAndSortedTransactions(DateTime startDate, DateTime endDate)
    {
        if (_transactions == null) return Enumerable.Empty<Transaction>();

        var filtered = _transactions
            .Where(t => t.LastUpdated >= startDate && t.LastUpdated <= endDate .AddDays(1).AddTicks(-1)); // inkluderar hela slutdatumet
    
        if (_sortByAmount)
            return _sortAmountDescending
                ? filtered.OrderByDescending(t => t.Amount)
                : filtered.OrderBy(t => t.Amount);

        return _sortDescending
            ? filtered.OrderByDescending(t => t.LastUpdated)
            : filtered.OrderBy(t => t.LastUpdated);
    }
    private DateTime StartDate { get; set; } = DateTime.Today.AddMonths(-1); // flyttar fram en månad som standard
    private DateTime EndDate { get; set; } = DateTime.Today; // dagens datum som standard
}

